{% extends "base.html" %}

{% block title %}Quest Runner - LLM Quest Benchmark{% endblock %}

{% block head %}
<!-- Monaco Editor -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.36.1/min/vs/loader.min.js"></script>
<!-- Marked for Markdown rendering -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
{% endblock %}

{% block content %}
<div class="row">
    <!-- Quest Configuration -->
    <div class="col-md-4">
        <div class="card">
            <div class="card-header">
                <h5 class="card-title mb-0">
                    <i class="fas fa-cog me-2"></i>Quest Configuration
                </h5>
            </div>
            <div class="card-body">
                <form id="questForm">
                    <!-- Quest Selection -->
                    <div class="mb-3">
                        <label for="questSelect" class="form-label">Select Quest</label>
                        <select class="form-select" id="questSelect" required>
                            {% for quest in quests %}
                            <option value="{{ quest }}" {% if quest == default_quest %}selected{% endif %}>{{ quest }}</option>
                            {% endfor %}
                        </select>
                    </div>

                    <!-- Model Selection -->
                    <div class="mb-3">
                        <label for="modelSelect" class="form-label">Model</label>
                        <select class="form-select" id="modelSelect" required>
                            {% for model in models %}
                            <option value="{{ model }}" {% if model == default_model %}selected{% endif %}>
                                {{ model }}
                            </option>
                            {% endfor %}
                        </select>
                    </div>

                    <!-- Template Selection -->
                    <div class="mb-3">
                        <label for="templateSelect" class="form-label">Prompt Template</label>
                        <select class="form-select" id="templateSelect" required>
                            {% for template in templates %}
                            {% if template != 'system_role' %}
                            <option value="{{ template }}" {% if template == default_template %}selected{% endif %}>
                                {{ template }}
                            </option>
                            {% endif %}
                            {% endfor %}
                        </select>
                    </div>

                    <!-- Template Content -->
                    <div class="mb-3">
                        <label class="form-label">Template Content</label>
                        <pre id="templateContent" class="bg-light p-2 rounded" style="max-height: 200px; overflow-y: auto; font-size: 12px;"></pre>
                    </div>

                    <!-- Temperature -->
                    <div class="mb-3">
                        <label for="temperature" class="form-label">Temperature</label>
                        <input type="number" class="form-control" id="temperature" value="{{ default_temperature }}" min="0" max="2" step="0.1" required>
                    </div>

                    <!-- Timeout -->
                    <div class="mb-3">
                        <label for="timeout" class="form-label">Timeout (seconds)</label>
                        <input type="number" class="form-control" id="timeout" value="60" min="1" required>
                    </div>

                    <button type="submit" class="btn btn-primary w-100">
                        <i class="fas fa-play me-2"></i>Run Quest
                    </button>
                </form>
            </div>
        </div>
    </div>

    <!-- Quest Output -->
    <div class="col-md-8">
        <div class="card">
            <div class="card-header">
                <h5 class="card-title mb-0">
                    <i class="fas fa-terminal me-2"></i>Quest Output
                </h5>
            </div>
            <div class="card-body">
                <!-- Progress -->
                <div id="questProgress" class="d-none">
                    <div class="alert alert-info mb-3">
                        <div class="d-flex align-items-center">
                            <div class="spinner-border text-primary me-3" role="status">
                                <span class="visually-hidden">Running...</span>
                            </div>
                            <div>
                                <h5 class="mb-1">Running Quest</h5>
                                <div id="currentQuestInfo" class="text-muted small"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Debug Output -->
                <div class="form-check form-switch mb-2">
                    <input class="form-check-input" type="checkbox" id="liveDebugToggle" checked>
                    <label class="form-check-label" for="liveDebugToggle">Show live decision trace</label>
                </div>
                <pre id="debugOutput" class="bg-dark text-light p-3 rounded" style="max-height: 420px; overflow-y: auto; font-family: monospace; font-size: 14px; line-height: 1.5; white-space: pre-wrap; word-wrap: break-word;"></pre>

                <h6 class="mt-3">Decision Timeline</h6>
                <div id="timelineContainer" class="list-group small" style="max-height: 170px; overflow-y: auto;">
                    <div class="list-group-item text-muted">No events yet.</div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    let debugLog = '';
    let activeRunId = null;
    let lastEventId = 0;
    let statusPollHandle = null;
    let eventsPollHandle = null;

    function wrapText(text, maxWidth = 120) {
        if (!text) return '';
        const words = String(text).split(' ');
        const lines = [];
        let line = '';
        words.forEach((word) => {
            if ((line + ' ' + word).trim().length > maxWidth) {
                if (line) lines.push(line);
                line = word;
            } else {
                line = (line ? `${line} ` : '') + word;
            }
        });
        if (line) lines.push(line);
        return lines.join('\n');
    }

    function appendDebugLog(text) {
        if (!document.getElementById('liveDebugToggle').checked) return;
        debugLog += wrapText(text, 120) + '\n';
        const formatted = debugLog
            .replace(/-----\s+STEP\s+\d+\s+-----/g, (m) => `<span style="color:#5bc0de;font-weight:bold;">${m}</span>`)
            .replace(/OUTCOME:\s+(SUCCESS)/g, '<span style="color:#5cb85c;font-weight:bold;">OUTCOME: $1</span>')
            .replace(/OUTCOME:\s+(FAILURE|ERROR|TIMEOUT)/g, '<span style="color:#d9534f;font-weight:bold;">OUTCOME: $1</span>')
            .replace(/(Reasoning|Analysis):\s+([^\n]+)/g, '<span style="color:#f0ad4e;font-weight:bold;">$1:</span> <span style="color:#d9d9d9;font-style:italic;">$2</span>');
        const out = document.getElementById('debugOutput');
        out.innerHTML = formatted;
        out.scrollTop = out.scrollHeight;
    }

    function resetTimeline() {
        const c = document.getElementById('timelineContainer');
        c.innerHTML = '<div class="list-group-item text-muted">No events yet.</div>';
    }

    function addTimelineItem(html) {
        const c = document.getElementById('timelineContainer');
        if (c.children.length === 1 && c.children[0].textContent.includes('No events yet')) {
            c.innerHTML = '';
        }
        const item = document.createElement('div');
        item.className = 'list-group-item';
        item.innerHTML = html;
        c.appendChild(item);
        c.scrollTop = c.scrollHeight;
    }

    async function loadTemplateContent() {
        const templateSelect = document.getElementById('templateSelect');
        const templateContent = document.getElementById('templateContent');
        try {
            const response = await fetch(`/monitor/template/${templateSelect.value}`);
            const data = await response.json();
            templateContent.textContent = data.success ? data.content : 'Error loading template content';
        } catch (error) {
            console.error('Error loading template:', error);
            templateContent.textContent = 'Error loading template content';
        }
    }

    function stopRunPolling() {
        if (statusPollHandle) clearInterval(statusPollHandle);
        if (eventsPollHandle) clearInterval(eventsPollHandle);
        statusPollHandle = null;
        eventsPollHandle = null;
    }

    function renderStepEvent(event) {
        const payload = event.payload || {};
        const choices = payload.choices || {};
        const selected = payload.llm_decision?.choice || {};
        const selectedEntry = Object.entries(selected)[0];
        const selectedText = selectedEntry ? `${selectedEntry[0]}: ${selectedEntry[1]}` : 'n/a';
        const reasoning = payload.llm_decision?.reasoning || null;
        const analysis = payload.llm_decision?.analysis || null;
        const isDefault = payload.llm_decision?.is_default ? ' default' : '';
        const parseMode = payload.llm_decision?.parse_mode || 'unknown';

        appendDebugLog(`----- STEP ${event.step || '-'} -----`);
        appendDebugLog(payload.observation || '');
        if (Object.keys(choices).length > 0) {
            appendDebugLog('Available choices:');
            Object.entries(choices).forEach(([idx, text]) => appendDebugLog(`${idx}. ${text}`));
        }
        appendDebugLog(`Selected option ${selectedText}${isDefault} [parse=${parseMode}]`);
        if (reasoning) appendDebugLog(`Reasoning: ${reasoning}`);
        if (analysis) appendDebugLog(`Analysis: ${analysis}`);

        const usage = payload.usage || {};
        const usageText = `${usage.prompt_tokens || 0}/${usage.completion_tokens || 0}/${usage.total_tokens || 0}`;
        addTimelineItem(
            `<div><strong>Step ${event.step || '-'}</strong> <span class="text-muted">(${event.location_id || '-'})</span></div>
             <div class="text-muted">choice: ${selectedText}</div>
             <div class="text-muted">parse: ${parseMode}${isDefault ? ' (default)' : ''}</div>
             <div class="text-muted">tokens p/c/t: ${usageText}</div>`
        );
    }

    async function pollRunEvents() {
        if (!activeRunId) return;
        try {
            const response = await fetch(`/monitor/runs/${activeRunId}/events?after_id=${lastEventId}&limit=200&compact=1`);
            const data = await response.json();
            if (!data.success) return;
            (data.events || []).forEach((event) => {
                lastEventId = Math.max(lastEventId, event.id || 0);
                if (event.event_type === 'step') {
                    renderStepEvent(event);
                } else if (event.event_type === 'outcome') {
                    appendDebugLog(`OUTCOME: ${event.payload?.outcome || 'UNKNOWN'}`);
                    addTimelineItem(`<div><strong>Outcome:</strong> ${event.payload?.outcome || 'UNKNOWN'}</div>`);
                } else if (event.event_type === 'timeout') {
                    appendDebugLog('OUTCOME: TIMEOUT');
                    addTimelineItem('<div><strong>Timeout</strong></div>');
                } else if (event.event_type === 'error') {
                    appendDebugLog(`Error: ${event.payload?.message || 'unknown error'}`);
                    addTimelineItem(`<div><strong>Error:</strong> ${event.payload?.message || 'unknown error'}</div>`);
                }
            });
        } catch (error) {
            console.error('Error polling run events:', error);
        }
    }

    async function pollRunStatus() {
        if (!activeRunId) return;
        try {
            const response = await fetch(`/monitor/run_status/${activeRunId}`);
            const data = await response.json();
            if (!data.success) return;

            const questProgress = document.getElementById('questProgress');
            const questInfo = document.getElementById('currentQuestInfo');
            questProgress.classList.remove('d-none');
            questInfo.textContent = `${data.current_task || 'Running'} | steps=${data.step_count || 0}`;

            if (data.status === 'complete' || data.status === 'error') {
                stopRunPolling();
                document.getElementById('questProgress').classList.add('d-none');
                appendDebugLog(`\nQuest run completed with status: ${data.status}`);
                if (data.error) appendDebugLog(`Error: ${data.error}`);
            }
        } catch (error) {
            console.error('Error polling run status:', error);
        }
    }

    loadTemplateContent();
    document.getElementById('templateSelect').addEventListener('change', loadTemplateContent);

    document.getElementById('questForm').addEventListener('submit', async function(e) {
        e.preventDefault();
        stopRunPolling();
        debugLog = '';
        resetTimeline();
        lastEventId = 0;
        activeRunId = null;

        const formData = {
            quest: document.getElementById('questSelect').value,
            model: document.getElementById('modelSelect').value,
            template: document.getElementById('templateSelect').value,
            timeout: parseInt(document.getElementById('timeout').value),
            temperature: parseFloat(document.getElementById('temperature').value)
        };
        appendDebugLog(`Starting quest: ${formData.quest}`);
        appendDebugLog(`Configuration: ${JSON.stringify(formData, null, 2)}`);

        try {
            const response = await fetch('/monitor/run_async', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(formData)
            });
            const result = await response.json();
            if (!result.success) {
                throw new Error(result.error || 'Failed to start run');
            }
            activeRunId = result.run_id;
            appendDebugLog(`Run ID: ${activeRunId}`);

            statusPollHandle = setInterval(pollRunStatus, 1500);
            eventsPollHandle = setInterval(pollRunEvents, 1200);
            pollRunStatus();
            pollRunEvents();
        } catch (error) {
            console.error('Error running quest:', error);
            appendDebugLog(`Error: ${error.message}`);
            document.getElementById('questProgress').classList.add('d-none');
            alert(`Error running quest: ${error.message}`);
        }
    });
</script>
{% endblock %}
